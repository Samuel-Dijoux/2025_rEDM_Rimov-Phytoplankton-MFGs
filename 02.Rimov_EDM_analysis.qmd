---
title: "02.Rimov_EDM_analysis"
format:
  html:
    toc: true
    toc-depth: 4
    toc-title: Contents
    toc-location: left-body
    embed-resources: true
    self-contained-math: true
date: today
date-format: long
editor: visual
author: Samuel Dijoux
execute:
  echo: true
  warning: false
  message: false
---

# Introduction

This script is dedicated to the empirical dynamical modelling analyses performed on time series of different morpho-functional groups of phytoplanktonic communities sampled in the Å˜imov reservoir (Czech Republic) between 1997 and 2021. We aim to address the question of how the different morpho-functional phytoplanktonic groups interact with one another regarding the fluctuating physical and chemical changes in the Rimov reservoir across the time period.

This document follows similar steps performed by *Liu and Gaines (2022). Environmental context dependency in species interactions* (PNAS), available here:

-   Paper <https://www.pnas.org/doi/abs/10.1073/pnas.2118539119?af=R>

-   Analysis <https://github.com/owenrliu/env_context_dependency>.

## Set up

Here is the state of the system with the different packages used. Load the required packages (if these are not installed on your system, use `install.packages()`)

```{r, warning=FALSE, message=FALSE, echo=FALSE}
library(tidyverse)
library(tidyr)
library(knitr)
library(kableExtra)
library(purrr)
library(dplyr)
library(tibble)
library(readr)
library(stringr)
library(lubridate)
library(forcats)
library(fields)

#devtools::install_github("ha0ye/rEDM")
library(rEDM)

library(ncdf4)
library(quantreg)
library(RANN)
library(ggsci)
library(here)

library(ggplot2)
library(plot3D)
library(igraph)
library(gridExtra)

library(RColorBrewer)
```

```{r, echo=FALSE}
print(sessionInfo())
```

### Plot theme

The following chunk defines the plot theme used across the analyses

```{r}
plot_theme <-   theme_minimal()+
  theme(text=element_text(family="sans",size=12,color="black"),
        legend.text = element_text(size=14),
        axis.title=element_text(family="sans",size=14),
        axis.text=element_text(family="sans",size=8),
        strip.background = element_rect(colour="black"),
        panel.border = element_rect(color="black",fill=NA))

theme_set(plot_theme)
```

# Description of the Rimov reservoir and studied Variables

Brief state of art of the Rimov reservoir (missin for now, to be added).

```{r, echo=FALSE}
load("Data/Rimov.datasets.RData")
```

```{r, echo=FALSE}
key.table <- tibble(dataset=c(rep("MFG Biovolume", 11),rep("Environment",9)),
                  short=c( names(Phyto), names(Env)),
                  long = c( paste0("MFG ", substr(colnames(Phyto_std), 5, 6)),
                           "Dissolved oxygen", "pH", "Conductometry", "Dissolved organic carbon",
                           "Total Phosphorus concentration", "Total Nitrogen concentration",
                           "Dissolved inorganic nitrogen", "Altitude of the water surface (m.a.s.l)", "Temperature"),
                  col = c( brewer.pal(11, 'RdYlBu'), brewer.pal(9, 'Paired')))
key.table$col[6] <- rgb(0,0,0)
```

```{r, warning=FALSE, echo=FALSE}
pd <- position_dodge(width=2)
variables <- c( names(Phyto), names(Env))

ts_list <- list()
for(i in 1:length(variables)){
  yname <- ifelse(i<=11,
                  paste0("Normalized Biovolume of MFG ", substr(variables[i], 5, 6)),
                  paste0("Normalized Index Value of ", variables[i]))
  
  data <- Rimov_std %>% select(Date, variables[i])
  colnames(data)[2] <- 'value'
  
  pp <- data %>%
    ggplot(aes(x=Date, y = value))+
    geom_hline(yintercept=0, lty=2)+
    geom_line(lwd=1, alpha=0.8, size=0.3, color = key.table[i,]$col)+
    xlab("Year")+ylab(yname)
  
  ts_list[[i]] = pp
}
```

Our dataset is composed of 11 morpho-functional groups (MFGs) of phytoplankton and up to 9 environmental variables, all processed in the same time period. The 11 selected MFGs were selected as they contributed to at least $2.5 \%$ to the total phytoplanktonic biovolume in average over the time period.

To perform empirical dynamic models, it is best to create normalized time series in order to not distort the state-space reconstruction due to differences in magnitudes between variables. For this, we thus normalized our data using a zero mean and standard deviation of 1. See the script `01. Rimov_data_format` for more details and codes.

```{r}
tibble(Variable=colnames(Phyto_std),
       Description = c(paste0("Normalized biomass of MFG ", substr(colnames(Phyto_std), 5,  6) ) )) %>% knitr::kable()
```

```{r}
tibble(Variable=colnames(Env_std),
       Description = paste0("Normalized ", c(
  "Dissolved oxygen", "pH", "Conductometry", "Dissolved organic carbon",
  "Total Phosphorus concentration", "Total Nitrogen concentration",
  "Dissolved inorganic nitrogen", "Altitude of the water surface (m.a.s.l)", "Temperature" ) )) %>% knitr::kable()
```

-   Morpho functional groups

```{r, echo=FALSE}
for(i in 1:11){
  print(ts_list[[i]])
}
```

-   Environmental variables

```{r, echo=FALSE}
for(i in 12:20){
  print(ts_list[[i]])
}
```

# Univariate predictability and nonlinearity

The main goal when using Empirical Dynamic Modelling is to reconstruct the behavior of system dynamics from our time series. The system state can be perceived as a point in a high-dimensional space, defined by fundamental state variables. As the system state change through time following a set of deterministic rules, it is possible to map a projection of the system state onto one of the coordinate axes.

The time series can be perceived as sequential projections of the motion of an attractor. The reconstruction of the system attractor is possible using lags of a time series then substituting the lagged time series for unknown or unobserved variables. If sufficient lags are used, the reconstruction preserves essential mathematical properties of the original system (Taken's Theorem, (Takens 1981)): the reconstructed state will map one-to-one to the actual system state, and nearby points in the reconstructed will correspond to similar system states. Instead of using a complete set of state variables to represent the system state, we use an E-dimensional lagged-coordinate embedding: $ \vec{x_t} = < x_t, x_{t - \tau}, ..., x_{t - (E-1)\tau} >$.

In the following, we perform a couple of analyses to verify that our time series are characterized by a deterministic and nonlinear behavior. This is done by using the the nearest neighbor forecasting method (or Simplex projection), which predict $x_{t+1}$ by finding the E+1 nearest neighbors of $x_t$ in the state space, and calculate the weighted average of the nearest neighbors' values at time $t+1$ from their Euclidean distance from $x_{t}$ at time $t$.

## Simplex, to identify Optimal embedding dimensions

We start by identifying the optimal embedded dimension $E$ that best *unfold* the dynamics of each variables. For each time series, we vary the embedded dimension $E$ and compare the estimated prediction skill $\rho$ (also called Pearson correlation coefficient), which measures the coefficient correlation between the predicted forecast and observed values. We then save the embedding dimension providing the highest prediction skill $\rho$.

```{r, echo=FALSE}
Rimov.Edim.list <- list(); j=1
for(i in 6:dim(Rimov_std)[2]){
  out <- EmbedDimension(dataFrame=Rimov_std, 
                        lib=c(1, floor(dim(Rimov_std)[1]/2) ),
                        pred=c(floor(dim(Rimov_std)[1]/2)+1, dim(Rimov_std)[1]),
                        columns = colnames(Rimov_std)[i], target = colnames(Rimov_std)[i], showPlot=F) %>% 
    mutate(ID = key.table$long[match(colnames(Rimov_std)[i],key.table$short)])
  Rimov.Edim.list[[j]] <- out; j <- j+1
  
}
rm(j, out)

# We saves the best dimension
Rimov.Edim.best <- sapply(Rimov.Edim.list, function(df){ df[which.max(df$rho),]$E })

maxE <- cbind.data.frame(E=Rimov.Edim.best, ID=key.table$long)
maxE <- maxE %>% mutate(short= key.table[which(maxE$ID==key.table$long),]$short )
```

-   Morpho-functional groups

```{r, echo=FALSE, warning=FALSE}
p1 <- bind_rows(Rimov.Edim.list[1:11]) %>%
  ggplot( aes(E, rho, colour = ID) )+
  geom_line(size=2)+
  facet_wrap(~ID, nrow=3, ncol=4, scales="free_y")+
  labs(x="Embedding Dimension (E)",y=expression(paste("Prediction Skill, ",rho)))+
  scale_x_continuous(breaks=seq(0,12,by=2))+
  guides(color=F)

p1+geom_vline( aes(xintercept=E), size=1, linetype=2, maxE[c(1:11),])
```

-   Environmental variables

```{r, echo=FALSE}
p2 <- bind_rows(Rimov.Edim.list[12:20]) %>%
  ggplot( aes(E, rho, colour = ID) )+
  geom_line(size=2)+
  facet_wrap(~ID, nrow=3, ncol=3, scales="free_y")+
  labs(x="Embedding Dimension (E)",y=expression(paste("Prediction Skill, ",rho)))+
  scale_x_continuous(breaks=seq(0,12,by=2))+
  guides(color=F)

p2+geom_vline( aes(xintercept=E), size=1, linetype=2, maxE[c(12:20),])
```

## Prediction decay test, to identify

We then investigate whether our time series are self predictable, with signals of deterministic behavior, and not characterized by purely stochastic behavior. In natural systems, short-term prediction are often possible using nearby trajectories, but the predictive state of the system is diluted over time, hindering long-term forecasting. Such phenomenon is coined as *deterministic chaos*, or *butterfly effect*. Thus deterministic time series should be characterized by diverging trajectories in state-space as time between neighboring points increases. Using simplex projection, we vary the prediction time $Tp$ while holding a constant embedding dimension, previously selected.

```{r, echo=FALSE}
Rimov.Tp.list <- list(); j=1
for(i in 6:dim(Rimov_std)[2]){
  out <- PredictInterval(dataFrame=Rimov_std, 
                        lib=c(1, floor(dim(Rimov_std)[1]/2) ),
                        pred=c(floor(dim(Rimov_std)[1]/2)+1, dim(Rimov_std)[1]),
                        columns = colnames(Rimov_std)[i], target = colnames(Rimov_std)[i],
                        E = maxE$E[j], showPlot=F) %>% 
    mutate(ID = key.table$long[match(colnames(Rimov_std)[i],key.table$short)])
  Rimov.Tp.list[[j]] <- out; j <- j+1
  
}
rm(j,out)
```

-   Morpho-functional groups

```{r, echo=FALSE}
(q1 <- bind_rows(Rimov.Tp.list[1:11]) %>%
  ggplot( aes(Tp, rho, colour = ID) )+
  geom_line(size=2)+
  facet_wrap(~ID, nrow=3, ncol=4, scales="free_y")+
  labs(x="Time to prediction (Tp)",y=expression(paste("Prediction Skill ",rho)))+
  scale_x_continuous(breaks=seq(0,12,by=2))+
  guides(color=F))
```
In overall most MFG time series show the expected decrease of prediction skill over time, characteristic of a deterministic behavior, but I have a doubt for the MFG 0, 1b and 2a. MFG 0 may have a purely stochastic dynamic, but the range of $\rho$ values is relatively small compared to other variables (between 0.05 and 0.15 vs. 0-0.8). This MFG might be characterized by a cyclic behavior.

-   Environmental variables

```{r, echo=FALSE}
(q2 <- bind_rows(Rimov.Tp.list[12:20]) %>%
  ggplot( aes(Tp, rho, colour = ID) )+
  geom_line(size=2)+
  facet_wrap(~ID, nrow=3, ncol=3, scales="free_y")+
  labs(x="Time to prediction (Tp)",y=expression(paste("Prediction Skill ",rho)))+
  scale_x_continuous(breaks=seq(0,12,by=2))+
  guides(color=F))
```

All environmental time series show the expected decrease of prediction skill over time, characteristic of a deterministic behavior. 

## S-maps, to identify nonlinear time series

We now analyse the time series to test whether they show nonlinear deterministic behavior or predictability, even if they are purely stochastic and behave similarly to autocorrelated red noise. We use S-maps (short for "sequentially weighted global linear maps") to distinguish nonlinear from stochastic dynamics. This method fits local linear maps to describe the dynamics. The nonlinear localisation parameter $\theta$ determines the degree to which individual points are weighted when fitting the local linear map. All points are equally weighed for $\theta = 0$, meaning that the local linear map is identical for all points in the reconstructed state-space, and that the S-map will identical to a global linear map (obtained for an autoregressive model). Oppositely, nearby points receive larger weights in the state-space for $\theta > 0$, and the local linear maps will differ in state-space to accommodate nonlinear behavior.

Thus greater predictive skill values $\rho$ observed - for $\theta = 0$ suggest that the S-map will be identical to a global linear map, i.e time series may be sampled from autoregressive red noise - for $\theta > 0$ suggest nonlinear dynamics. Better forecasts are achieved when the local linear map can change depending on the location map $\theta$.

Following, we build the S-maps for the different time series using the optimal embedding dimensions previously analysed.

```{r, echo=FALSE}
Rimov.Smaps.list <- list(); j=1
for(i in 6:dim(Rimov_std)[2]){
  out <- PredictNonlinear(dataFrame=Rimov_std, 
                        lib=c(1, floor(dim(Rimov_std)[1]/2) ),
                        pred=c(floor(dim(Rimov_std)[1]/2)+1, dim(Rimov_std)[1]),
                        columns = colnames(Rimov_std)[i], target = colnames(Rimov_std)[i],
                        E = maxE$E[j], showPlot=F) %>% 
    mutate(ID = key.table$long[match(colnames(Rimov_std)[i],key.table$short)])
  Rimov.Smaps.list[[j]] <- out; j <- j+1
}
rm(j,out)

# We saves the best dimension
Rimov.Theta.best <- sapply(Rimov.Smaps.list, function(df){ df[which.max(df$rho),]$Theta })
maxTh <- cbind.data.frame(Theta=Rimov.Theta.best, ID=key.table$long)
maxTh <- maxTh %>% mutate(short= key.table[which(maxTh$ID==key.table$long),]$short )
```

-   Morpho-functional groups

```{r, echo=FALSE}
r1 <- bind_rows(Rimov.Smaps.list[1:11]) %>%
  ggplot( aes(Theta, rho, colour = ID) )+
  geom_line(size=2)+
  facet_wrap(~ID, nrow=3, ncol=4, scales="free_y")+
  labs(x=expression(paste("S-map localisation ", theta)),y=expression(paste("Prediction Skill  ",rho)))+
  scale_x_continuous(breaks=seq(0,12,by=2))+
  guides(color=F)

r1+geom_vline( aes(xintercept=Theta), size=1, linetype=2, maxTh[c(1:11),])
```

For all MFGs, best prediction skill is improved for positive $\theta$ across all outputs, suggesting nonlinear dynamics for these variables. Declines in forecast skill past the optimal $\theta$ (in dashed lines) indicate that local linear maps overfit to insufficient neighbors.

-   Environmental variables

```{r, echo=FALSE}
r2 <- bind_rows(Rimov.Smaps.list[12:20]) %>%
  ggplot( aes(Theta, rho, colour = ID) )+
  geom_line(size=2)+
  facet_wrap(~ID, nrow=3, ncol=3, scales="free_y")+
  labs(x=expression(paste("S-map localisation ", theta)),y=expression(paste("Prediction Skill ",rho)))+
  scale_x_continuous(breaks=seq(0,12,by=2))+
  guides(color=F)

r2+geom_vline( aes(xintercept=Theta), size=1, linetype=2, maxTh[c(12:20),])
```

5 of our 9 selected drivers seem to be characterized by linear dynamics, which higher predictive skill observed at $\theta = 0$ for Altitude of the water surface, DIN, DOC, TN and TP.

The remaining 4 drivers (Conductometry, DO, pH and Temperature) seem to be characterized by nonlinear dynamics.

# Causal inference and Convergent Cross Mapping

two-part criterion for CCM to be a rigorous test of causality
1. The cross map prediction skill is statistically significant (i.e. $\rho > 0$) when using the full time series as the library
2. Cross map prediction demonstrates convergence, i.e. rho increases as more of the time series is used for the library and the reconstructed attractor becomes more dense

We build a ccm across all time series using MFG and environmental variables as forcing variables (in column) and MFGs as predicted variables

```{r, eval=T, echo=FALSE}
n_row <- dim(Phyto_std)[2]
n_col <- dim(Rimov_std)[2]-5

col_names <- colnames(Rimov_std)[6:25]
row_names <- colnames(Phyto_std)

Rimov.Xmap.matrix <- array(NA,dim=c(n_row,n_col),dimnames=list(row_names,col_names))
```

We build 3 matrices storing the different CCM output to:

-   test the significance of the cross map prediction skill: the first to store a bootstrapped p-value, measuring the probability that a given xmap is greater than zero (calculated as 1 minus the number of positive results for rho divided by the number of iterations)

-   test of convergence: a similar matrix storing a t-test value between library size 10 and 336 to see if the predictive skill is greater at large library size compared to at small library 

-   the third matrix is used as index of causality, if both previous tests have been passed

```{r}
Rimov.p1.mat <- array(NA,dim=c(n_row,n_col),dimnames=list(row_names,col_names))
Rimov.p2.mat <- array(NA,dim=c(n_row,n_col),dimnames=list(row_names,col_names))
Rimov.ptot.mat <- array(NA,dim=c(n_row,n_col),dimnames=list(row_names,col_names))
```

```{r, eval=F, echo=FALSE}
for(i in 1:n_row) {
  for(j in 1:n_col) {
    if(i != j) {
      # remember, we use the best embedding dimension for the target variable (the variable we're cross-mapping to, i.e. the putative forcing variable)
      tempE=maxE[col_names[j]]$E
      temp <- suppressWarnings(ccm(westend,lib=as.matrix(westend.segs),pred=as.matrix(westend.segs),E=tempE,lib_column= 2+i,target_column = 2+j,lib_sizes = c(10,500),num_samples=100,replace=T,silent=T,RNGseed = 41389))
      
     # mean rho at library size 500
      rhomeans <- temp %>% ccm_means()
      westend.xmap_mat[i,j] <- rhomeans$rho[rhomeans$lib_size==500]
      
      # first p-value (is cross map skill greater than zero? at library size 500)
      p1 <- temp %>% filter(lib_size==500) %>% 
        mutate(pos=ifelse(rho>0,1,0)) %>%
        summarise(p=(1-sum(pos)/n()))
      westend.p1.mat[i,j] <- as.numeric(p1)
      
      # second p-value (rho at lib-size 500 greater than rho at lib-size 10? By more than 0.1?)
      p2 <- t.test(temp$rho[temp$lib_size==10],temp$rho[temp$lib_size==500])$p.value
      if((rhomeans$rho[rhomeans$lib_size==500]-rhomeans$rho[rhomeans$lib_size==10])<0.1) p2 <- 1
      westend.p2.mat[i,j] <- as.numeric(p2)
      
      # overall significance (both p1 and p2 signficant at alpha 0.05)
      westend.ptot.mat[i,j] <- ifelse(p1<0.05 & p2<0.05,1,0)
    }
  }
}
```


```{r, eval=FALSE, echo=FALSE}
var_pairs <- combn(vars, 2)
E_pairs <- rep(maxE$E, each=(length(vars)-1)/2 )

length(E_pairs)
dim(var_pairs)

(20*19)/2


n <- dim(Rimov_std) [1]
libSizes = paste(10, n, 5, collapse= " " )

ccm_matrix = array(NA, dim = c(length(vars), length(vars)), dimnames = list(vars,
vars))

for (i in 1:ncol(var_pairs)) {
  ccm_out = CCM(dataFrame = Rimov_std,
                columns = var_pairs[1, i], target = var_pairs[2, i],
                libSizes = libSizes, Tp = 0,
                E = maxE$E[which(maxE$ID=var_pairs[1, i]),], sample = 100)
  
  outVars = names(ccm_out)
  var_out = unlist(strsplit(outVars[2], ":"))
  ccm_matrix[var_out[2], var_out[1]] = ccm_out[1, 2]
  var_out = unlist(strsplit(outVars[3], ":"))
  ccm_matrix[var_out[2], var_out[1]] = ccm_out[1, 3]
  }

```

```{r, eval=FALSE, echo=FALSE}
vars <- names(Rimov_std)[6:25]
var_pairs <- combn(vars, 2)
E_pairs <- rep(maxE$E, each=length(vars)-1)

n <- dim(Rimov_std) [1]
libSizes = paste(10, n, 5, collapse= " " )


CCM_rho_matrix <- matrix(NA, nrow = length(vars), ncol = length(vars),
                         dimnames = list(vars, vars))

e = 1
for (CCM_from in vars) {
    for (CCM_to in vars[vars != CCM_from]) {
        out_ccm <- CCM(dataFrame = Rimov_std, E = maxE$E[e],
                       column = CCM_from, target = CCM_to,
                       libSizes = libSizes, showPlot = F)
        CCM_rho_matrix[CCM_from, CCM_to] <- out_ccm$rho
    }
  e = e+1
}

ccm_rho_matrix2
```

```{r, eval=FALSE, echo=FALSE}
for (ccm_from in vars) {
  for (ccm_to in vars[vars != ccm_from]) {
    ccm_out = CCM(dataFrame = Thrips, columns = var_pairs[1, i], target = var_pairs[2,
i], libSizes = libSize, Tp = 0, E = E, sample = 100)
    }
}
```

## Acknowledgement

The analyses made below, were possible Two essential hat tips have to be made for the production of these analyses:

-   The rEDM tutorial

-   Empirical dynamic dynamic modelling analyses by Owen Liu.
